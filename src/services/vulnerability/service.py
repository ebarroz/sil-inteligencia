"""
Vulnerability detection service for the SIL Predictive System.

This module identifies and flags vulnerable equipment based on tracking status and maintenance records.
"""

import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
import uuid

from ..models.equipment.equipment import EquipmentBase, EquipmentStatus, TrackingStatus

# Configuração de logging
logger = logging.getLogger(__name__)

class VulnerabilityDetectionService:
    """Serviço para detecção de vulnerabilidade em equipamentos."""
    
    def __init__(self, db_manager):
        """
        Inicializa o serviço de detecção de vulnerabilidade.
        
        Args:
            db_manager: Gerenciador de banco de dados
        """
        self.db_manager = db_manager
        logger.info("Serviço de detecção de vulnerabilidade inicializado")
    
    def identify_vulnerable_equipment(
        self,
        client_id: Optional[str] = None,
        include_details: bool = True
    ) -> Dict[str, Any]:
        """
        Identifica equipamentos vulneráveis com base em critérios de rastreamento e manutenção.
        
        Args:
            client_id: ID do cliente para filtrar (opcional)
            include_details: Se deve incluir detalhes completos dos equipamentos
            
        Returns:
            Resultado da detecção de vulnerabilidade
        """
        try:
            # Obter equipamentos vulneráveis
            vulnerable_equipment = self._get_vulnerable_equipment(client_id)
            
            # Agrupar por tipo de vulnerabilidade
            vulnerability_groups = {
                "not_tracked": [],
                "minimally_tracked": [],
                "maintenance_overdue": [],
                "high_failure_rate": []
            }
            
            for equipment in vulnerable_equipment:
                # Determinar tipos de vulnerabilidade
                vulnerabilities = []
                
                if equipment["tracking_status"] == "NOT_TRACKED":
                    vulnerabilities.append("not_tracked")
                    vulnerability_groups["not_tracked"].append(equipment["id"])
                
                elif equipment["tracking_status"] == "MINIMALLY_TRACKED":
                    vulnerabilities.append("minimally_tracked")
                    vulnerability_groups["minimally_tracked"].append(equipment["id"])
                
                if equipment.get("maintenance_overdue", False):
                    vulnerabilities.append("maintenance_overdue")
                    vulnerability_groups["maintenance_overdue"].append(equipment["id"])
                
                if equipment.get("high_failure_rate", False):
                    vulnerabilities.append("high_failure_rate")
                    vulnerability_groups["high_failure_rate"].append(equipment["id"])
                
                # Adicionar tipos de vulnerabilidade ao equipamento
                equipment["vulnerabilities"] = vulnerabilities
            
            # Calcular estatísticas
            stats = {
                "total_equipment": len(vulnerable_equipment),
                "not_tracked_count": len(vulnerability_groups["not_tracked"]),
                "minimally_tracked_count": len(vulnerability_groups["minimally_tracked"]),
                "maintenance_overdue_count": len(vulnerability_groups["maintenance_overdue"]),
                "high_failure_rate_count": len(vulnerability_groups["high_failure_rate"])
            }
            
            # Preparar resultado
            result = {
                "success": True,
                "stats": stats,
                "vulnerability_groups": vulnerability_groups
            }
            
            # Incluir detalhes completos se solicitado
            if include_details:
                result["equipment"] = vulnerable_equipment
            
            return result
        except Exception as e:
            logger.error(f"Erro ao identificar equipamentos vulneráveis: {e}")
            return {
                "success": False,
                "message": f"Erro ao identificar equipamentos vulneráveis: {str(e)}"
            }
    
    def _get_vulnerable_equipment(self, client_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Obtém lista de equipamentos vulneráveis.
        
        Args:
            client_id: ID do cliente para filtrar (opcional)
            
        Returns:
            Lista de equipamentos vulneráveis
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor() as cursor:
                    # Construir consulta base
                    query = """
                    SELECT
                        e.id, e.tag, e.name, e.type, e.model, e.manufacturer,
                        e.serial_number, e.installation_date, e.status, e.tracking_status,
                        e.last_maintenance_date, e.next_maintenance_date,
                        e.maintenance_history, e.measurement_history, e.location,
                        c.id as client_id, c.name as client_name,
                        (
                            SELECT COUNT(*)
                            FROM alerts a
                            WHERE a.equipment_id = e.id
                            AND a.timestamp >= NOW() - INTERVAL '90 days'
                        ) as alert_count_90d
                    FROM equipment e
                    JOIN clients c ON e.client_id = c.id
                    WHERE (
                        e.tracking_status IN ('NOT_TRACKED', 'MINIMALLY_TRACKED')
                        OR (e.next_maintenance_date IS NOT NULL AND e.next_maintenance_date < NOW())
                    )
                    """
                    
                    # Adicionar filtro de cliente se fornecido
                    params = []
                    if client_id:
                        query += " AND c.id = %s"
                        params.append(client_id)
                    
                    # Adicionar ordenação
                    query += " ORDER BY c.name, e.name"
                    
                    cursor.execute(query, params)
                    
                    vulnerable_equipment = []
                    for row in cursor.fetchall():
                        # Determinar se a manutenção está atrasada
                        maintenance_overdue = False
                        if row[11]:  # next_maintenance_date
                            maintenance_overdue = row[11] < datetime.now()
                        
                        # Determinar se há alta taxa de falhas
                        high_failure_rate = row[17] >= 5  # Mais de 5 alertas nos últimos 90 dias
                        
                        equipment = {
                            "id": row[0],
                            "tag": row[1],
                            "name": row[2],
                            "type": row[3],
                            "model": row[4],
                            "manufacturer": row[5],
                            "serial_number": row[6],
                            "installation_date": row[7],
                            "status": row[8],
                            "tracking_status": row[9],
                            "last_maintenance_date": row[10],
                            "next_maintenance_date": row[11],
                            "maintenance_history": row[12] or [],
                            "location": row[14],
                            "client_id": row[15],
                            "client_name": row[16],
                            "alert_count_90d": row[17],
                            "maintenance_overdue": maintenance_overdue,
                            "high_failure_rate": high_failure_rate
                        }
                        
                        vulnerable_equipment.append(equipment)
                    
                    return vulnerable_equipment
        except Exception as e:
            logger.error(f"Erro ao obter equipamentos vulneráveis: {e}")
            raise
    
    def update_vulnerability_flags(self) -> Dict[str, Any]:
        """
        Atualiza flags de vulnerabilidade para todos os equipamentos.
        
        Returns:
            Resultado da atualização
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor() as cursor:
                    # Atualizar flag de vulnerabilidade para equipamentos não rastreados ou minimamente rastreados
                    cursor.execute(
                        """
                        UPDATE equipment
                        SET is_vulnerable = TRUE,
                            vulnerability_reasons = ARRAY['tracking_status'],
                            updated_at = NOW()
                        WHERE tracking_status IN ('NOT_TRACKED', 'MINIMALLY_TRACKED')
                        """
                    )
                    
                    tracking_status_count = cursor.rowcount
                    
                    # Atualizar flag de vulnerabilidade para equipamentos com manutenção atrasada
                    cursor.execute(
                        """
                        UPDATE equipment
                        SET is_vulnerable = TRUE,
                            vulnerability_reasons = 
                                CASE 
                                    WHEN vulnerability_reasons IS NULL THEN ARRAY['maintenance_overdue']
                                    WHEN 'maintenance_overdue' = ANY(vulnerability_reasons) THEN vulnerability_reasons
                                    ELSE vulnerability_reasons || ARRAY['maintenance_overdue']
                                END,
                            updated_at = NOW()
                        WHERE next_maintenance_date IS NOT NULL
                        AND next_maintenance_date < NOW()
                        """
                    )
                    
                    maintenance_overdue_count = cursor.rowcount
                    
                    # Atualizar flag de vulnerabilidade para equipamentos com alta taxa de falhas
                    cursor.execute(
                        """
                        UPDATE equipment e
                        SET is_vulnerable = TRUE,
                            vulnerability_reasons = 
                                CASE 
                                    WHEN vulnerability_reasons IS NULL THEN ARRAY['high_failure_rate']
                                    WHEN 'high_failure_rate' = ANY(vulnerability_reasons) THEN vulnerability_reasons
                                    ELSE vulnerability_reasons || ARRAY['high_failure_rate']
                                END,
                            updated_at = NOW()
                        WHERE (
                            SELECT COUNT(*)
                            FROM alerts a
                            WHERE a.equipment_id = e.id
                            AND a.timestamp >= NOW() - INTERVAL '90 days'
                        ) >= 5
                        """
                    )
                    
                    high_failure_rate_count = cursor.rowcount
                    
                    # Remover flag de vulnerabilidade para equipamentos que não atendem mais aos critérios
                    cursor.execute(
                        """
                        UPDATE equipment e
                        SET is_vulnerable = FALSE,
                            vulnerability_reasons = NULL,
                            updated_at = NOW()
                        WHERE is_vulnerable = TRUE
                        AND tracking_status = 'FULLY_TRACKED'
                        AND (next_maintenance_date IS NULL OR next_maintenance_date >= NOW())
                        AND (
                            SELECT COUNT(*)
                            FROM alerts a
                            WHERE a.equipment_id = e.id
                            AND a.timestamp >= NOW() - INTERVAL '90 days'
                        ) < 5
                        """
                    )
                    
                    removed_count = cursor.rowcount
                    
                    conn.commit()
                    
                    return {
                        "success": True,
                        "tracking_status_count": tracking_status_count,
                        "maintenance_overdue_count": maintenance_overdue_count,
                        "high_failure_rate_count": high_failure_rate_count,
                        "removed_count": removed_count,
                        "total_updated": tracking_status_count + maintenance_overdue_count + high_failure_rate_count + removed_count
                    }
        except Exception as e:
            logger.error(f"Erro ao atualizar flags de vulnerabilidade: {e}")
            return {
                "success": False,
                "message": f"Erro ao atualizar flags de vulnerabilidade: {str(e)}"
            }
    
    def get_vulnerability_report(
        self,
        client_id: Optional[str] = None,
        include_recommendations: bool = True
    ) -> Dict[str, Any]:
        """
        Gera um relatório de vulnerabilidade para equipamentos.
        
        Args:
            client_id: ID do cliente para filtrar (opcional)
            include_recommendations: Se deve incluir recomendações para cada equipamento
            
        Returns:
            Relatório de vulnerabilidade
        """
        try:
            # Identificar equipamentos vulneráveis
            vulnerability_result = self.identify_vulnerable_equipment(
                client_id=client_id,
                include_details=True
            )
            
            if not vulnerability_result.get("success", False):
                return vulnerability_result
            
            # Preparar relatório
            report = {
                "generated_at": datetime.now(),
                "stats": vulnerability_result["stats"],
                "vulnerability_groups": vulnerability_result["vulnerability_groups"],
                "client_summary": []
            }
            
            # Agrupar por cliente
            client_equipment = {}
            for equipment in vulnerability_result.get("equipment", []):
                client_id = equipment["client_id"]
                if client_id not in client_equipment:
                    client_equipment[client_id] = {
                        "client_id": client_id,
                        "client_name": equipment["client_name"],
                        "equipment": []
                    }
                
                client_equipment[client_id]["equipment"].append(equipment)
            
            # Adicionar recomendações se solicitado
            if include_recommendations:
                for client_id, client_data in client_equipment.items():
                    for equipment in client_data["equipment"]:
                        equipment["recommendations"] = self._generate_recommendations(equipment)
            
            # Adicionar resumo por cliente
            for client_id, client_data in client_equipment.items():
                equipment_count = len(client_data["equipment"])
                
                # Contar tipos de vulnerabilidade
                vulnerability_counts = {
                    "not_tracked": 0,
                    "minimally_tracked": 0,
                    "maintenance_overdue": 0,
                    "high_failure_rate": 0
                }
                
                for equipment in client_data["equipment"]:
                    for vulnerability in equipment.get("vulnerabilities", []):
                        if vulnerability in vulnerability_counts:
                            vulnerability_counts[vulnerability] += 1
                
                # Calcular pontuação de risco (quanto maior, mais vulnerável)
                risk_score = (
                    vulnerability_counts["not_tracked"] * 10 +
                    vulnerability_counts["minimally_tracked"] * 5 +
                    vulnerability_counts["maintenance_overdue"] * 7 +
                    vulnerability_counts["high_failure_rate"] * 8
                )
                
                # Determinar nível de risco
                risk_level = "LOW"
                if risk_score >= 50:
                    risk_level = "HIGH"
                elif risk_score >= 20:
                    risk_level = "MEDIUM"
                
                client_summary = {
                    "client_id": client_id,
                    "client_name": client_data["client_name"],
                    "vulnerable_equipment_count": equipment_count,
                    "vulnerability_counts": vulnerability_counts,
                    "risk_score": risk_score,
                    "risk_level": risk_level
                }
                
                report["client_summary"].append(client_summary)
            
            # Ordenar resumo por pontuação de risco (decrescente)
            report["client_summary"].sort(key=lambda x: x["risk_score"], reverse=True)
            
            return {
                "success": True,
                "report": report
            }
        except Exception as e:
            logger.error(f"Erro ao gerar relatório de vulnerabilidade: {e}")
            return {
                "success": False,
                "message": f"Erro ao gerar relatório de vulnerabilidade: {str(e)}"
            }
    
    def _generate_recommendations(self, equipment: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Gera recomendações para um equipamento vulnerável.
        
        Args:
            equipment: Informações do equipamento
            
        Returns:
            Lista de recomendações
        """
        recommendations = []
        
        # Recomendações com base no status de rastreamento
        if equipment["tracking_status"] == "NOT_TRACKED":
            recommendations.append({
                "type": "tracking",
                "priority": "HIGH",
                "description": "Implementar monitoramento completo para este equipamento, incluindo termografia, análise de óleo e vibração."
            })
        elif equipment["tracking_status"] == "MINIMALLY_TRACKED":
            recommendations.append({
                "type": "tracking",
                "priority": "MEDIUM",
                "description": "Expandir o monitoramento atual para incluir fontes de dados adicionais."
            })
        
        # Recomendações com base na manutenção
        if equipment.get("maintenance_overdue", False):
            days_overdue = 0
            if equipment["next_maintenance_date"]:
                days_overdue = (datetime.now() - equipment["next_maintenance_date"]).days
            
            priority = "MEDIUM"
            if days_overdue > 30:
                priority = "HIGH"
            
            recommendations.append({
                "type": "maintenance",
                "priority": priority,
                "description": f"Agendar manutenção preventiva imediatamente. Manutenção atrasada em {days_overdue} dias."
            })
        
        # Recomendações com base na taxa de falhas
        if equipment.get("high_failure_rate", False):
            recommendations.append({
                "type": "analysis",
                "priority": "HIGH",
                "description": f"Realizar análise de causa raiz para identificar padrões de falha recorrentes. {equipment['alert_count_90d']} alertas nos últimos 90 dias."
            })
        
        return recommendations

logger.info("Vulnerability detection service defined.")
"""
