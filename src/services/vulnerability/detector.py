"""
Identificação de Equipamentos Vulneráveis - SIL Predictive System
----------------------------------------------------------------
Este módulo implementa a identificação de equipamentos vulneráveis com base no rastreamento,
conforme requisito de "Considerar como vuneravél aqueles equipamentos que não estiverem sendo 
trackeados adequadamente tanto na questão de manuntenção online e manunteção offline".
"""
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import json
import sqlite3
import os

# Configuração de logging
logger = logging.getLogger(__name__)

class VulnerabilityDetector:
    """Serviço para identificação de equipamentos vulneráveis."""
    
    def __init__(self, config: Dict[str, Any]):
        """
        Inicializa o serviço de detecção de vulnerabilidades.
        
        Args:
            config: Configurações do serviço
        """
        self.config = config
        self.db_path = config.get("db_path", "data/sil_integrated.db")
        self.maintenance_threshold = config.get("maintenance_threshold", 90)  # Dias
        self.measurement_threshold = config.get("measurement_threshold", 7)   # Dias
        self.alert_threshold = config.get("alert_threshold", 3)               # Alertas P1/P2 sem resolução
        
        logger.info("Serviço de detecção de vulnerabilidades inicializado")
    
    def detect_vulnerable_equipment(self) -> List[Dict[str, Any]]:
        """
        Identifica equipamentos vulneráveis com base em critérios de rastreamento.
        
        Returns:
            List[Dict[str, Any]]: Lista de equipamentos vulneráveis com detalhes
        """
        logger.info("Iniciando detecção de equipamentos vulneráveis")
        
        vulnerable_equipment = []
        
        # Verifica equipamentos com manutenção vencida
        maintenance_overdue = self._detect_maintenance_overdue()
        vulnerable_equipment.extend(maintenance_overdue)
        
        # Verifica equipamentos sem medições recentes
        no_recent_measurements = self._detect_no_recent_measurements()
        
        # Adiciona apenas equipamentos que não estão já na lista
        for equipment in no_recent_measurements:
            if not any(e["id"] == equipment["id"] for e in vulnerable_equipment):
                vulnerable_equipment.append(equipment)
        
        # Verifica equipamentos com alertas não resolvidos
        unresolved_alerts = self._detect_unresolved_alerts()
        
        # Adiciona apenas equipamentos que não estão já na lista
        for equipment in unresolved_alerts:
            if not any(e["id"] == equipment["id"] for e in vulnerable_equipment):
                vulnerable_equipment.append(equipment)
        
        logger.info(f"Detecção concluída: {len(vulnerable_equipment)} equipamentos vulneráveis identificados")
        return vulnerable_equipment
    def _detect_maintenance_overdue(self) -> List[Dict[str, Any]]:
        """
        Identifica equipamentos com manutenção vencida.
        
        Returns:
            List[Dict[str, Any]]: Lista de equipamentos vulneráveis por manutenção
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Data limite para considerar manutenção vencida
            threshold_date = (datetime.utcnow() - timedelta(days=self.maintenance_threshold)).isoformat()
            
            # Busca equipamentos com manutenção vencida ou sem registro de manutenção
            cursor.execute('''
            SELECT e.*, c.name as client_name
            FROM unified_equipment e
            LEFT JOIN unified_clients c ON e.client_id = c.id
            WHERE 
                (e.last_maintenance < ? OR e.last_maintenance IS NULL)
                AND e.status != 'INACTIVE'
            ''', (threshold_date,))
            
            results = []
            for row in cursor.fetchall():
                equipment = dict(row)
                equipment['vulnerability_type'] = 'maintenance_overdue'
                equipment['vulnerability_details'] = {
                    'threshold_days': self.maintenance_threshold,
                    'last_maintenance': equipment.get('last_maintenance', 'Nunca realizada'),
                    'days_overdue': self._calculate_days_overdue(equipment.get('last_maintenance'))
                }
                results.append(equipment)
            
            conn.close()
            logger.info(f"Identificados {len(results)} equipamentos com manutenção vencida")
            return results
            
        except Exception as e:
            logger.error(f"Erro ao detectar equipamentos com manutenção vencida: {str(e)}")
            return []
    
    def _detect_no_recent_measurements(self) -> List[Dict[str, Any]]:
        """
        Identifica equipamentos sem medições recentes.
        
        Returns:
            List[Dict[str, Any]]: Lista de equipamentos vulneráveis por falta de medições
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Data limite para considerar medições recentes
            threshold_date = (datetime.utcnow() - timedelta(days=self.measurement_threshold)).isoformat()
            
            # Busca equipamentos sem medições recentes
            cursor.execute('''
            SELECT e.*, c.name as client_name
            FROM unified_equipment e
            LEFT JOIN unified_clients c ON e.client_id = c.id
            WHERE e.id NOT IN (
                SELECT DISTINCT equipment_id 
                FROM unified_measurements 
                WHERE timestamp > ?
            )
            AND e.status != 'INACTIVE'
            ''', (threshold_date,))
            
            results = []
            for row in cursor.fetchall():
                equipment = dict(row)
                
                # Busca a data da última medição
                cursor.execute('''
                SELECT MAX(timestamp) as last_measurement
                FROM unified_measurements
                WHERE equipment_id = ?
                ''', (equipment['id'],))
                
                last_measurement = cursor.fetchone()
                last_measurement_date = last_measurement['last_measurement'] if last_measurement else None
                
                equipment['vulnerability_type'] = 'no_recent_measurements'
                equipment['vulnerability_details'] = {
                    'threshold_days': self.measurement_threshold,
                    'last_measurement': last_measurement_date or 'Sem medições',
                    'days_without_measurement': self._calculate_days_overdue(last_measurement_date)
                }
                results.append(equipment)
            
            conn.close()
            logger.info(f"Identificados {len(results)} equipamentos sem medições recentes")
            return results
            
        except Exception as e:
            logger.error(f"Erro ao detectar equipamentos sem medições recentes: {str(e)}")
            return []
    def _detect_unresolved_alerts(self) -> List[Dict[str, Any]]:
        """
        Identifica equipamentos com alertas não resolvidos.
        
        Returns:
            List[Dict[str, Any]]: Lista de equipamentos vulneráveis por alertas
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Busca equipamentos com alertas P1/P2 não resolvidos
            cursor.execute('''
            SELECT e.*, c.name as client_name,
                   COUNT(CASE WHEN a.gravity = 'P1' THEN 1 END) as p1_count,
                   COUNT(CASE WHEN a.gravity = 'P2' THEN 1 END) as p2_count
            FROM unified_equipment e
            LEFT JOIN unified_clients c ON e.client_id = c.id
            JOIN unified_alerts a ON e.id = a.equipment_id
            WHERE a.status NOT IN ('RESOLVED', 'FALSE_POSITIVE')
            AND a.gravity IN ('P1', 'P2')
            AND e.status != 'INACTIVE'
            GROUP BY e.id
            HAVING (p1_count + p2_count) >= ?
            ''', (self.alert_threshold,))
            
            results = []
            for row in cursor.fetchall():
                equipment = dict(row)
                
                # Busca detalhes dos alertas não resolvidos
                cursor.execute('''
                SELECT id, gravity, status, description, timestamp
                FROM unified_alerts
                WHERE equipment_id = ?
                AND status NOT IN ('RESOLVED', 'FALSE_POSITIVE')
                AND gravity IN ('P1', 'P2')
                ORDER BY 
                    CASE gravity 
                        WHEN 'P1' THEN 1 
                        WHEN 'P2' THEN 2 
                        ELSE 3 
                    END,
                    timestamp DESC
                ''', (equipment['id'],))
                
                unresolved_alerts = [dict(alert) for alert in cursor.fetchall()]
                
                equipment['vulnerability_type'] = 'unresolved_alerts'
                equipment['vulnerability_details'] = {
                    'threshold_count': self.alert_threshold,
                    'p1_count': equipment['p1_count'],
                    'p2_count': equipment['p2_count'],
                    'total_count': equipment['p1_count'] + equipment['p2_count'],
                    'alerts': unresolved_alerts
                }
                
                # Remove campos temporários
                equipment.pop('p1_count', None)
                equipment.pop('p2_count', None)
                
                results.append(equipment)
            
            conn.close()
            logger.info(f"Identificados {len(results)} equipamentos com alertas não resolvidos")
            return results
            
        except Exception as e:
            logger.error(f"Erro ao detectar equipamentos com alertas não resolvidos: {str(e)}")
            return []
    
    def _calculate_days_overdue(self, date_str: Optional[str]) -> int:
        """
        Calcula dias de atraso a partir de uma data.
        
        Args:
            date_str: Data em formato ISO
            
        Returns:
            int: Número de dias de atraso
        """
        if not date_str:
            return 999  # Valor alto para indicar ausência de data
        
        try:
            date = datetime.fromisoformat(date_str)
            days = (datetime.utcnow() - date).days
            return max(0, days)
        except (ValueError, TypeError):
            return 999
    
    def flag_vulnerable_equipment(self, equipment_list: List[Dict[str, Any]]) -> None:
        """
        Marca equipamentos como vulneráveis no banco de dados.
        
        Args:
            equipment_list: Lista de equipamentos vulneráveis
        """
        if not equipment_list:
            logger.info("Nenhum equipamento vulnerável para marcar")
            return
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Atualiza status de vulnerabilidade
            for equipment in equipment_list:
                vulnerability_details = json.dumps(equipment.get('vulnerability_details', {}))
                
                cursor.execute('''
                UPDATE unified_equipment
                SET 
                    is_vulnerable = 1,
                    vulnerability_type = ?,
                    vulnerability_details = ?,
                    vulnerability_updated_at = ?
                WHERE id = ?
                ''', (
                    equipment.get('vulnerability_type', 'unknown'),
                    vulnerability_details,
                    datetime.utcnow().isoformat(),
                    equipment['id']
                ))
            
            # Reseta status de vulnerabilidade para equipamentos que não estão mais na lista
            equipment_ids = [e['id'] for e in equipment_list]
            placeholders = ','.join(['?' for _ in equipment_ids])
            
            if equipment_ids:
                cursor.execute(f'''
                UPDATE unified_equipment
                SET 
                    is_vulnerable = 0,
                    vulnerability_type = NULL,
                    vulnerability_details = NULL,
                    vulnerability_updated_at = ?
                WHERE is_vulnerable = 1
                AND id NOT IN ({placeholders})
                ''', [datetime.utcnow().isoformat()] + equipment_ids)
            
            conn.commit()
            conn.close()
            
            logger.info(f"Marcados {len(equipment_list)} equipamentos como vulneráveis")
            
        except Exception as e:
            logger.error(f"Erro ao marcar equipamentos vulneráveis: {str(e)}")
